const nodeExternals = require('webpack-node-externals');
const normalize = require('postcss-normalize');
const autoprefixer = require('autoprefixer');
const cssVariables = require('postcss-css-variables');
const { compact } = require('lodash');
const path = require('path');

const { createBabelConfig } = require('./babel');

const { srcDirectory, excludedPatterns } = require('./variables');

const {
  ifReact,
  ifHot,
  isProd,
  shouldTypeCheck,
  ifProd,
  ifTest,
} = require('@hollowverse/utils/helpers/env');

const sassLoaders = [
  {
    loader: 'resolve-url-loader',
    options: {
      sourceMap: true,
    },
  },
  {
    loader: 'sass-loader',
    options: {
      sourceMap: true,
      includePaths: [srcDirectory],
    },
  },
];

const postCssPlugins = [
  autoprefixer,

  // Inlines the value of custom CSS properties
  // for browsers that do not support them
  cssVariables({
    /**
     * `preserve` keeps both the custom property declarations and usages
     * as well as the resolved values as a fallback, so that we can change
     * the values dynamically via JavaScript in browsers that do
     * support custom properties.
     */
    preserve: true,
  }),
];

/**
 * @param {object} options
 * @param {boolean=} options.isServer
 */
exports.createGlobalCssLoaders = (options = { isServer: false }) => [
  {
    // For the server bundle, we do not want to generate any CSS files,
    // we are only interested in the class name to use in the SSR markup.
    // That's what css-loader/locals does.
    loader: options.isServer ? 'css-loader/locals' : 'css-loader',
    query: {
      minimize: isProd,
      sourceMap: true,
      modules: false,
    },
  },
  {
    loader: 'postcss-loader',
    options: {
      ident: 'postcss',
      plugins: [
        // Minimal cross-browser CSS resets, only contains resets relevant
        // for the targeted browsers as specified in `"browserslist"` in `package.json`
        normalize({ forceImport: true }),
        ...postCssPlugins,
      ],
      sourceMap: true,
    },
  },
  ...sassLoaders,
];

/**
 * @param {object} options
 * @param {boolean=} options.isServer
 */
exports.createCssModulesLoaders = (options = { isServer: false }) => [
  {
    // For the server bundle, we do not want to generate any CSS files,
    // we are only interested in the class name to use in the SSR markup.
    // That's what css-loader/locals does.
    loader: options.isServer
      ? 'css-loader/locals'
      : ifProd('typings-for-css-modules-loader') || 'css-loader',

    query: {
      minimize: isProd,
      sourceMap: true,
      modules: true,
      camelCase: 'only',

      // Options specific to `typings-for-css-modules-loader`
      namedExport: true,
      banner:
        '// This file is automatically generated.\n// Please do not modify it.\n',

      localIdentName:
        // Do not scope the class names in tests, otherwise
        // every change to CSS styles will require updating the
        // snapshots.
        ifTest('[name]__[local]') ||
        // Shorten the class name in production bundles to save some bytes
        ifProd('[hash:base64:5]') ||
        '[name]__[local]--[hash:base64:5]',
    },
  },
  {
    loader: 'postcss-loader',
    ident: 'postcss',
    options: {
      sourceMap: true,
      plugins: [
        // @WARN Do not include `normalize`
        ...postCssPlugins,
      ],
    },
  },
  ...sassLoaders,
];

/**
 * @param {object} options
 * @param {boolean} options.isServer
 */
exports.createScriptRules = options => {
  const babelLoader = options.babelLoader || {
    loader: 'babel-loader',
    options: createBabelConfig(options),
  };

  return [
    // Babel
    {
      test: /\.jsx?$/,
      exclude: excludedPatterns,
      use: compact([
        // ifReact(ifHot('react-hot-loader/webpack')),
        babelLoader,
      ]),
    },

    {
      test: /\.(ts|tsx)$/,
      loader: 'hot-self-accept-loader',
      include: [path.join(srcDirectory, 'pages')],
      options: {
        extensions: /\.(ts|tsx)$/,
      },
    },

    // TypeScript
    {
      test: /\.tsx?$/,
      exclude: excludedPatterns,
      use: compact([
        // ifReact(ifHot('react-hot-loader/webpack')),
        babelLoader,
        {
          loader: 'ts-loader',
          options: {
            silent: true,
            transpileOnly: !shouldTypeCheck,
            compilerOptions: {
              noEmitOnError: shouldTypeCheck,
            },
          },
        },
      ]),
    },
  ];
};

/**
 * By default, webpack will consume and bundle all `require` calls.
 * `externals` specifies which packages should *not* be bundled by webpack.
 * The following packages are already installed on the server, so they do
 * not need to be bundled. This also reduces the build time for the server bundle.
 * The `webpack-node-externals` package will exclude all packages in `node_modules`
 * so they are not bundled.
 * @param {Record<string, string>} aliases
 */
exports.createExternals = aliases =>
  nodeExternals({
    // `whitelist` excludes node modules so they _are_ bundled with webpack
    whitelist: [
      '.bin',
      'babel-polyfill',

      /**
       * @param {string} moduleName
       */
      moduleName =>
        [
          // These packages need to be bundled so that they
          // know they are running in the context of webpack runtime
          'babel-plugin-universal-import',
          'webpack-flush-chunks',
          'react-universal-component',

          // All aliased packages should be bundled.
          // Example: when using preact instead of React, require('react') should be bundled.
          // Otherwise, the call to require('react') will resolve to the actual
          // `react` package
          ...Object.keys(aliases),
        ].some(match => moduleName.includes(match)),
    ],
  });
